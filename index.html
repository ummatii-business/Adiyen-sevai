<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mini Runner (Phaser 3) â€” Single File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <!-- Phaser 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.min.js"></script>
  <style>
    html, body { height:100%; margin:0; background:#0b1020; }
    #game { width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="game"></div>

  <script>
  // --- Config ---
  const W = 480, H = 720;
  const LANES = [W*0.25, W*0.5, W*0.75];
  const START_SPEED = 220;          // downward scroll px/s
  const SPEED_INCREMENT = 0.02;     // per second
  const OBSTACLE_RATE = 900;        // ms
  const COIN_RATE = 500;            // ms
  const PLAYER_Y = H - 120;
  const LANE_SWITCH_TIME = 120;     // ms
  const MAX_HEARTS = 1;             // keep 1 like Subway Surfers (game over on hit)

  let game;

  class MainScene extends Phaser.Scene {
    constructor(){ super('main'); }

    preload(){
      // Create minimal shapes as textures (no external assets)
      this.makeRect('player', 60, 60, 0x4fd1c5);      // teal square
      this.makeRect('obstacle', 70, 70, 0xff5a5f);    // coral
      this.makeCircle('coin', 20, 0xffd166);          // gold coin
      this.makeRect('laneMark', 8, 40, 0xffffff);     // road dash
      this.makeRect('btn', 220, 60, 0x2d3748);        // UI button
    }

    create(){
      // World state
      this.scrollSpeed = START_SPEED;
      this.elapsed = 0;
      this.score = 0;
      this.best = +localStorage.getItem('bestScore_v1') || 0;
      this.hearts = MAX_HEARTS;
      this.gameOver = false;

      // Background "road" bands
      this.add.rectangle(W/2, H/2, W, H, 0x111827);
      this.add.rectangle(W/2, H/2, W*0.8, H, 0x0f172a).setStrokeStyle(4, 0x1f2937);

      // Lane lines
      this.addLineDashes();

      // Player
      this.currentLane = 1;
      this.player = this.physics.add.image(LANES[this.currentLane], PLAYER_Y, 'player')
        .setDepth(10).setImmovable(true);
      this.player.body.allowGravity = false;

      // Groups
      this.obstacles = this.physics.add.group();
      this.coins = this.physics.add.group();

      // Colliders
      this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);
      this.physics.add.overlap(this.player, this.obstacles, this.hitObstacle, null, this);

      // UI
      this.scoreText = this.add.text(16, 14, 'Score: 0', { fontFamily:'monospace', fontSize: 22, color:'#e2e8f0' });
      this.bestText  = this.add.text(W-16, 14, `Best: ${this.best}`, { fontFamily:'monospace', fontSize: 22, color:'#94a3b8' }).setOrigin(1,0);
      this.speedText = this.add.text(16, 42, 'Speed: 0', { fontFamily:'monospace', fontSize: 16, color:'#94a3b8' });

      // Input
      this.cursors = this.input.keyboard.createCursorKeys();
      this.input.keyboard.on('keydown-LEFT', ()=>this.switchLane(-1));
      this.input.keyboard.on('keydown-RIGHT', ()=>this.switchLane(+1));
      this.input.keyboard.on('keydown-A', ()=>this.switchLane(-1));
      this.input.keyboard.on('keydown-D', ()=>this.switchLane(+1));
      this.input.keyboard.on('keydown-SPACE', ()=>{ if(this.gameOver) this.restart(); });

      // Touch swipe
      this.swipeStart = null;
      this.input.on('pointerdown', p=> this.swipeStart = {x:p.x, y:p.y, t:this.time.now});
      this.input.on('pointerup', p=>{
        if(!this.swipeStart) return;
        const dx = p.x - this.swipeStart.x, dy = p.y - this.swipeStart.y;
        if(Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
          this.switchLane(dx > 0 ? +1 : -1);
        } else if (this.gameOver && this.time.now - this.swipeStart.t < 400) {
          this.restart();
        }
        this.swipeStart = null;
      });

      // Spawners
      this.obstacleTimer = this.time.addEvent({ delay: OBSTACLE_RATE, loop:true, callback: this.spawnObstacle, callbackScope: this });
      this.coinTimer = this.time.addEvent({ delay: COIN_RATE, loop:true, callback: this.spawnCoinRow, callbackScope: this });
    }

    update(time, dt){
      if(this.gameOver) return;

      const delta = dt / 1000;
      this.elapsed += delta;

      // Gradually increase scrolling speed
      this.scrollSpeed += SPEED_INCREMENT * this.scrollSpeed * delta;

      // Move lane dashes
      this.laneDashes.children.iterate(d=>{
        d.y += this.scrollSpeed * delta;
        if(d.y > H + 30) d.y = -30;
      });

      // Move obstacles & coins downward
      this.moveGroup(this.obstacles, delta);
      this.moveGroup(this.coins, delta);

      // Cleanup offscreen
      this.cleanupGroup(this.obstacles);
      this.cleanupGroup(this.coins);

      // Score increments with time and coin collection
      this.score += delta * 10;
      this.scoreText.setText('Score: ' + Math.floor(this.score));
      this.speedText.setText('Speed: ' + Math.floor(this.scrollSpeed));

      // Keyboard hold (optional quick nudge)
      if (Phaser.Input.Keyboard.JustDown(this.cursors.left))  this.switchLane(-1);
      if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) this.switchLane(+1);
    }

    // --- Helpers ---
    makeRect(key, w, h, color){
      const g = this.make.graphics({x:0,y:0, add:false});
      g.fillStyle(color, 1); g.fillRoundedRect(0,0,w,h,12);
      g.lineStyle(6, 0x0b1020, 1); g.strokeRoundedRect(0,0,w,h,12);
      g.generateTexture(key, w, h); g.destroy();
    }
    makeCircle(key, r, color){
      const d = r*2;
      const g = this.make.graphics({x:0,y:0, add:false});
      g.fillStyle(color,1); g.fillCircle(r,r,r);
      g.lineStyle(6, 0x9a7b00, 1); g.strokeCircle(r,r,r-3);
      g.generateTexture(key, d, d); g.destroy();
    }

    addLineDashes(){
      this.laneDashes = this.add.group();
      const cols = [LANES[0] + (LANES[1]-LANES[0])/2, LANES[1] + (LANES[2]-LANES[1])/2];
      for (const x of cols){
        for (let y=-30; y<H+60; y+=60){
          const dash = this.add.image(x, y, 'laneMark').setAlpha(0.35);
          this.laneDashes.add(dash);
        }
      }
    }

    switchLane(dir){
      if(this.gameOver) return;
      const targetLane = Phaser.Math.Clamp(this.currentLane + dir, 0, 2);
      if (targetLane === this.currentLane) return;
      this.currentLane = targetLane;
      this.tweens.add({
        targets: this.player,
        x: LANES[this.currentLane],
        duration: LANE_SWITCH_TIME,
        ease: 'Sine.easeOut'
      });
    }

    spawnObstacle(){
      if(this.gameOver) return;
      const lane = Phaser.Math.Between(0,2);
      const x = LANES[lane];
      const o = this.obstacles.create(x, -80, 'obstacle');
      o.setData('type','obstacle');
      o.setImmovable(true);
      o.body.allowGravity = false;
      o.setAngle(Phaser.Math.Between(-6,6));
      // Make some obstacles thinner/taller
      if(Math.random()<0.35){
        o.setScale(1, Phaser.Math.FloatBetween(0.8, 1.6));
        o.body.updateFromGameObject();
      }
    }

    spawnCoinRow(){
      if(this.gameOver) return;
      // 50% chance to spawn coins; avoid overlapping with fresh obstacle at same frame
      if (Math.random() < 0.5) return;

      const lanesForCoins = Phaser.Utils.Array.Shuffle([0,1,2]).slice(Phaser.Math.Between(1,3));
      for(const lane of lanesForCoins){
        // Create a small vertical line of coins
        const count = Phaser.Math.Between(2, 5);
        for(let i=0;i<count;i++){
          const c = this.coins.create(LANES[lane], -40 - i*44, 'coin');
          c.body.allowGravity = false;
          c.setData('type','coin');
        }
      }
    }

    moveGroup(group, delta){
      group.children.iterate(obj=>{
        if(!obj) return;
        obj.y += this.scrollSpeed * delta;
      });
    }

    cleanupGroup(group){
      group.children.iterate(obj=>{
        if (obj && obj.y > H + 100) obj.destroy();
      });
    }

    collectCoin(player, coin){
      coin.destroy();
      this.score += 20;
      // brief ping animation
      this.tweens.add({ targets: this.player, scale: 1.08, yoyo:true, duration:80 });
    }

    hitObstacle(player, obstacle){
      if(this.gameOver) return;
      this.hearts -= 1;
      if(this.hearts <= 0){
        this.triggerGameOver();
      } else {
        obstacle.destroy();
        this.tweens.add({ targets: this.player, alpha: 0.2, duration:80, yoyo:true, repeat:4 });
      }
    }

    triggerGameOver(){
      this.gameOver = true;
      this.obstacleTimer.remove(false);
      this.coinTimer.remove(false);

      // Save best
      const finalScore = Math.floor(this.score);
      if(finalScore > this.best){
        this.best = finalScore;
        localStorage.setItem('bestScore_v1', String(this.best));
      }

      // Dim overlay
      const overlay = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.5).setDepth(100);

      // Panel
      const panel = this.add.container(W/2, H/2).setDepth(101);
      const bg = this.add.image(0, 0, 'btn').setScale(1.2, 2).setAlpha(0.95);
      const title = this.add.text(0, -80, 'Game Over', { fontFamily:'monospace', fontSize: 40, color:'#f8fafc' }).setOrigin(0.5);
      const s1 = this.add.text(0, -20, `Score: ${finalScore}`, { fontFamily:'monospace', fontSize: 26, color:'#e2e8f0' }).setOrigin(0.5);
      const s2 = this.add.text(0, 20, `Best: ${this.best}`, { fontFamily:'monospace', fontSize: 22, color:'#94a3b8' }).setOrigin(0.5);
      const tip = this.add.text(0, 80, 'Tap / Space / Swipe to Restart', { fontFamily:'monospace', fontSize: 16, color:'#cbd5e1' }).setOrigin(0.5);

      panel.add([bg, title, s1, s2, tip]);

      // Restart interactions
      this.input.once('pointerup', ()=> this.restart());
      this.input.keyboard.once('keydown-SPACE', ()=> this.restart());
    }

    restart(){
      this.scene.restart();
    }
  }

  const cfg = {
    type: Phaser.AUTO,
    width: W, height: H,
    parent: 'game',
    backgroundColor: '#0b1020',
    physics: { default:'arcade', arcade:{ debug:false } },
    scene: [MainScene],
    scale: {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH
    }
  };

  window.addEventListener('load', ()=>{
    game = new Phaser.Game(cfg);
  });
  </script>
</body>
</html>
