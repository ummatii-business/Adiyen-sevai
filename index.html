<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mini Runner (Centered Road)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <!-- Phaser 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.min.js"></script>
  <style>
    html, body { height:100%; margin:0; background:#0b1020; }
    #game { width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="game"></div>

  <script>
  // --- Config ---
  const W = 480, H = 720;
  const ROAD_WIDTH = W * 0.6;    // road width (centered)
  const LANES = [
    W/2 - ROAD_WIDTH/3,   // left lane
    W/2,                  // middle lane
    W/2 + ROAD_WIDTH/3    // right lane
  ];
  const START_SPEED = 220;
  const SPEED_INCREMENT = 0.02;
  const OBSTACLE_RATE = 900;
  const COIN_RATE = 500;
  const PLAYER_Y = H - 120;
  const LANE_SWITCH_TIME = 120;

  let game;

  class MainScene extends Phaser.Scene {
    constructor(){ super('main'); }

    preload(){
      this.makeRect('player', 60, 60, 0x4fd1c5);
      this.makeRect('obstacle', 70, 70, 0xff5a5f);
      this.makeCircle('coin', 20, 0xffd166);
      this.makeRect('laneMark', 8, 40, 0xffffff);
      this.makeRect('btn', 220, 60, 0x2d3748);
    }

    create(){
      this.scrollSpeed = START_SPEED;
      this.score = 0;
      this.best = +localStorage.getItem('bestScore_v1') || 0;
      this.gameOver = false;

      // --- Road background (centered & aligned) ---
      this.add.rectangle(W/2, H/2, ROAD_WIDTH+60, H, 0x0f172a).setStrokeStyle(4, 0x1f2937);
      this.add.rectangle(W/2, H/2, ROAD_WIDTH, H, 0x111827);

      // Lane dashes
      this.addLineDashes();

      // Player starts in middle lane
      this.currentLane = 1;
      this.player = this.physics.add.image(LANES[this.currentLane], PLAYER_Y, 'player')
        .setDepth(10).setImmovable(true);
      this.player.body.allowGravity = false;

      // Groups
      this.obstacles = this.physics.add.group();
      this.coins = this.physics.add.group();

      // Colliders
      this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);
      this.physics.add.overlap(this.player, this.obstacles, this.hitObstacle, null, this);

      // UI
      this.scoreText = this.add.text(16, 14, 'Score: 0', { fontFamily:'monospace', fontSize: 22, color:'#e2e8f0' });
      this.bestText  = this.add.text(W-16, 14, `Best: ${this.best}`, { fontFamily:'monospace', fontSize: 22, color:'#94a3b8' }).setOrigin(1,0);

      // Input
      this.input.keyboard.on('keydown-LEFT', ()=>this.switchLane(-1));
      this.input.keyboard.on('keydown-RIGHT', ()=>this.switchLane(+1));
      this.input.keyboard.on('keydown-A', ()=>this.switchLane(-1));
      this.input.keyboard.on('keydown-D', ()=>this.switchLane(+1));
      this.input.keyboard.on('keydown-SPACE', ()=>{ if(this.gameOver) this.restart(); });

      // Swipe
      this.swipeStart = null;
      this.input.on('pointerdown', p=> this.swipeStart = {x:p.x,y:p.y});
      this.input.on('pointerup', p=>{
        if(!this.swipeStart) return;
        const dx = p.x - this.swipeStart.x;
        if(Math.abs(dx) > 30) this.switchLane(dx > 0 ? +1 : -1);
        else if(this.gameOver) this.restart();
        this.swipeStart = null;
      });

      // Spawners
      this.obstacleTimer = this.time.addEvent({ delay: OBSTACLE_RATE, loop:true, callback: this.spawnObstacle, callbackScope: this });
      this.coinTimer = this.time.addEvent({ delay: COIN_RATE, loop:true, callback: this.spawnCoinRow, callbackScope: this });
    }

    update(time, dt){
      if(this.gameOver) return;
      const delta = dt / 1000;
      this.scrollSpeed += SPEED_INCREMENT * this.scrollSpeed * delta;

      // Move lane dashes
      this.laneDashes.children.iterate(d=>{
        d.y += this.scrollSpeed * delta;
        if(d.y > H + 30) d.y = -30;
      });

      // Move obstacles & coins
      this.moveGroup(this.obstacles, delta);
      this.moveGroup(this.coins, delta);

      // Cleanup
      this.cleanupGroup(this.obstacles);
      this.cleanupGroup(this.coins);

      // Score
      this.score += delta * 10;
      this.scoreText.setText('Score: ' + Math.floor(this.score));
    }

    // --- Helpers ---
    makeRect(key, w, h, color){
      const g = this.make.graphics({x:0,y:0, add:false});
      g.fillStyle(color, 1); g.fillRoundedRect(0,0,w,h,12);
      g.generateTexture(key, w, h); g.destroy();
    }
    makeCircle(key, r, color){
      const g = this.make.graphics({x:0,y:0, add:false});
      g.fillStyle(color,1); g.fillCircle(r,r,r);
      g.generateTexture(key, r*2, r*2); g.destroy();
    }

    addLineDashes(){
      this.laneDashes = this.add.group();
      for (let i=1; i<LANES.length; i++){
        const x = (LANES[i-1] + LANES[i]) / 2;
        for (let y=-30; y<H+60; y+=60){
          this.laneDashes.add(this.add.image(x, y, 'laneMark').setAlpha(0.4));
        }
      }
    }

    switchLane(dir){
      if(this.gameOver) return;
      const targetLane = Phaser.Math.Clamp(this.currentLane + dir, 0, 2);
      if (targetLane === this.currentLane) return;
      this.currentLane = targetLane;
      this.tweens.add({
        targets: this.player,
        x: LANES[this.currentLane],
        duration: LANE_SWITCH_TIME,
        ease: 'Sine.easeOut'
      });
    }

    spawnObstacle(){
      const lane = Phaser.Math.Between(0,2);
      const o = this.obstacles.create(LANES[lane], -80, 'obstacle');
      o.body.allowGravity = false;
    }

    spawnCoinRow(){
      const lane = Phaser.Math.Between(0,2);
      const c = this.coins.create(LANES[lane], -40, 'coin');
      c.body.allowGravity = false;
    }

    moveGroup(group, delta){
      group.children.iterate(obj=>{
        if(obj) obj.y += this.scrollSpeed * delta;
      });
    }
    cleanupGroup(group){
      group.children.iterate(obj=>{
        if(obj && obj.y > H+100) obj.destroy();
      });
    }

    collectCoin(player, coin){
      coin.destroy();
      this.score += 20;
    }
    hitObstacle(player, obstacle){
      if(this.gameOver) return;
      this.gameOver = true;
      this.obstacleTimer.remove();
      this.coinTimer.remove();

      const finalScore = Math.floor(this.score);
      if(finalScore > this.best){
        this.best = finalScore;
        localStorage.setItem('bestScore_v1', String(this.best));
      }

      this.add.text(W/2, H/2, 'Game Over\nScore: '+finalScore+'\nTap/Space to Restart',
        { fontFamily:'monospace', fontSize:28, color:'#f8fafc', align:'center' }).setOrigin(0.5);

      this.input.once('pointerup', ()=> this.restart());
      this.input.keyboard.once('keydown-SPACE', ()=> this.restart());
    }

    restart(){ this.scene.restart(); }
  }

  const cfg = {
    type: Phaser.AUTO,
    width: W, height: H,
    parent: 'game',
    backgroundColor: '#0b1020',
    physics: { default:'arcade' },
    scene: [MainScene],
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
  };

  window.addEventListener('load', ()=>{ game = new Phaser.Game(cfg); });
  </script>
</body>
</html>
